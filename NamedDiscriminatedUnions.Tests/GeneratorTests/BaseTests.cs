using NamedDiscriminatedUnions.Generators;
using Xunit.Abstractions;

namespace NamedDiscriminatedUnions.Tests.GeneratorTests;

public static class BaseTests
{
    [Fact]
    public static void AppendHeader()
    {
        using var writer = Helper.GetIndentedTextWriter();

        BaseGenerator.AppendHeader(writer);
        var str = writer.InnerWriter.ToString();

        str.Should().Be("""
            // <auto-generated/>

            #nullable enable


            """);
    }

    [Theory]
    [InlineData(null, "")]
    [InlineData("", "")]
    [InlineData("TestNamespace", """
        namespace TestNamespace;


        """)]
    [InlineData("Long.Nested.irregular.NaMeSpaCe", """
        namespace Long.Nested.irregular.NaMeSpaCe;


        """)]
    public static void AppendNamespace(string? fullNamespace, string expected)
    {
        using var writer = Helper.GetIndentedTextWriter();

        BaseGenerator.AppendNamespace(writer, fullNamespace);
        var str = writer.InnerWriter.ToString();

        str.Should().Be(expected);
    }

    [Theory]
    [InlineData("Union", new string[] { }, """
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct Union

        """)]
    [InlineData("FunnyUnionName", new string[] { "T" }, """
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct FunnyUnionName<T>
        
        """)]
    [InlineData("Union", new string[] { "K", "V" }, """
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct Union<K, V>
        
        """)]
    public static void AppendDeclaration(string typeName, string[] generics, string expected)
    {
        using var writer = Helper.GetIndentedTextWriter();

        BaseGenerator.AppendDeclaration(writer, typeName, generics);
        var str = writer.InnerWriter.ToString();

        str.Should().Be(expected);
    }

    [Theory]
    [InlineData("Union", new string[] { }, "Union")]
    [InlineData("FunnyUnionName", new string[] { "T" }, "FunnyUnionName<T>")]
    [InlineData("Union", new string[] { "K", "V" }, "Union<K, V>")]
    public static void GetFullTypeNameWithGenerics(string typeName, string[] generics, string expected)
    {
        var str = BaseGenerator.GetFullTypeNameWithGenerics(typeName, generics);

        str.Should().Be(expected);
    }

    [Fact]
    public static void AppendFields()
    {
        using var writer = Helper.GetIndentedTextWriter();

        BaseGenerator.AppendFields(writer);
        var str = writer.InnerWriter.ToString();

        str.Should().Be("""
            private readonly Tag tag;


            """);
    }

    [Theory]
    [MemberData(nameof(GetCouldBeNullParameters))]
    internal static void CouldBeNull(CouldBeNullParameters parameters)
    {
        var type = new ParsedType() { FullTypeName = parameters.FullTypeName, IsValueType = parameters.IsValueType, IsReferenceType = parameters.IsReferenceType };

        var res = BaseGenerator.CouldBeNull(type);

        res.Should().Be(parameters.Expected);
    }

    public record struct CouldBeNullParameters(string FullTypeName, bool IsValueType, bool IsReferenceType, bool Expected) : IXunitSerializable
    {
        void IXunitSerializable.Deserialize(IXunitSerializationInfo info)
        {
            FullTypeName = info.GetValue<string>(nameof(FullTypeName));
            IsValueType = info.GetValue<bool>(nameof(IsValueType));
            IsReferenceType = info.GetValue<bool>(nameof(IsReferenceType));
            Expected = info.GetValue<bool>(nameof(Expected));
        }

        readonly void IXunitSerializable.Serialize(IXunitSerializationInfo info)
        {
            info.AddValue(nameof(FullTypeName), FullTypeName);
            info.AddValue(nameof(IsValueType), IsValueType);
            info.AddValue(nameof(IsReferenceType), IsReferenceType);
            info.AddValue(nameof(Expected), Expected);
        }
    }

    public static TheoryData<CouldBeNullParameters> GetCouldBeNullParameters()
    {
        return new()
        {
            { new ("int", true, false, false) },
            { new ("int?", true, false, true) },
            { new ("System.Collections.Generic.HashSet<int>", false, true, true) },
            { new ("System.Collections.Generic.HashSet<int>?", false, true, true) },
            { new ("T", false, false, true) }, // no constraints
            { new ("T", true, false, false) }, // where T : struct
            { new ("T?", true, false, true) }, // where T : struct
            { new ("T", false, true, true) }, // where T : class
            { new ("T?", false, true, true) }, // where T : class
        };
    }
}
