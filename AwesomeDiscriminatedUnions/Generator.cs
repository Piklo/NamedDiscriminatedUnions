using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Threading;

namespace AwesomeDiscriminatedUnions;

internal readonly record struct DiscriminatedUnionData(string Name, string FullNamespace);

internal readonly record struct DiscriminatedUnionAttributeData(DiscriminatedUnionData Union, EqualsType EqualsType, GetHashCodeType GetHashCodeType);

internal readonly record struct DiscriminatedUnionTypesData(DiscriminatedUnionData Union, ImmutableArray<ParsedType> Types);

internal readonly record struct ParsedType(string FullTypeName, string TypeName, bool IsValueType, string CustomName, int Priority, bool ShouldBox);

// remove the readonly if you ever add more attributes and just update the existing record with whatever changed in subsequent transforms
internal readonly record struct MergedAttributesData(DiscriminatedUnionData Union, ImmutableArray<ParsedType> Types, EqualsType EqualsType, GetHashCodeType GetHashCodeType);

[Generator]
internal class Generator : IIncrementalGenerator
{
    private readonly static string tab = new(' ', 4);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var duAttribute =
            context.SyntaxProvider.ForAttributeWithMetadataName("AwesomeDiscriminatedUnions.DiscriminatedUnionAttribute", Predicate, TransformDiscriminatedUnionAttribute)
            .Collect()
            .Select(static (codes, ct) =>
            {
                var dict = new Dictionary<DiscriminatedUnionData, DiscriminatedUnionAttributeData>(codes.Length);
                foreach (var item in codes)
                {
                    dict.Add(item.Union, item);
                }
                return dict;
            });

        var duTypes =
            context.SyntaxProvider.ForAttributeWithMetadataName("AwesomeDiscriminatedUnions.DiscriminatedUnionTypeAttribute", Predicate, TransformTypes)
            .Collect();

        var mergedAttributes = duTypes.Combine(duAttribute).SelectMany(static (item, ct) =>
        {
            var parsedTypes = item.Left;
            var dict = item.Right;
            var list = new List<MergedAttributesData>(parsedTypes.Length);

            foreach (var types in parsedTypes)
            {
                ct.ThrowIfCancellationRequested();

                if (dict.TryGetValue(types.Union, out var duData))
                {
                    list.Add(new MergedAttributesData(types.Union, types.Types, duData.EqualsType, duData.GetHashCodeType));
                }
                else
                {
                    list.Add(new MergedAttributesData(types.Union, types.Types, GetDefaultEqualsType(), GetDefaultGetHashCodeType()));
                }
            }

            return list;
        });

        context.RegisterSourceOutput(mergedAttributes, (productionContext, mergedAttributes) =>
        {
            var getHashCodeType = mergedAttributes.GetHashCodeType;

            var fileName = $"{mergedAttributes.Union.Name}.g.cs";
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine($"// generated on {DateTimeOffset.Now}");
            builder.AppendLine();
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Runtime.InteropServices;");
            builder.AppendLine();
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {mergedAttributes.Union.FullNamespace}");
            builder.AppendLine("{");
            builder.AppendLine($"{tab}[StructLayout(LayoutKind.Explicit)]");
            builder.AppendLine($"{tab}partial struct {mergedAttributes.Union.Name}");
            builder.AppendLine($"{tab}{{");
            AppendConstTags(builder, mergedAttributes.Types);
            AppendFields(builder, mergedAttributes.Types);
            AppendConstructors(builder, mergedAttributes);
            AppendIsXyzMethods(builder, mergedAttributes.Types);
            AppendMatchMethod(builder, mergedAttributes.Types);
            AppendSwitchMethod(builder, mergedAttributes.Types);
            AppendImplicitCastOperators(builder, mergedAttributes);
            AppendGetHashCodeMethod(builder, mergedAttributes);
            builder.AppendLine($"{tab}}}");
            builder.AppendLine("}");
            var code = builder.ToString();
            Console.WriteLine();
            productionContext.AddSource(fileName, code);
        });
    }

    private static bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is StructDeclarationSyntax;
    }

    private static DiscriminatedUnionAttributeData TransformDiscriminatedUnionAttribute(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var name = context.TargetSymbol.Name;
        var fullNamespace = GetFullNamespace(context.TargetSymbol);
        var union = new DiscriminatedUnionData(name, fullNamespace);

        if (context.Attributes.Length != 1)
        {
            return new DiscriminatedUnionAttributeData(union, GetDefaultEqualsType(), GetDefaultGetHashCodeType());
        }

        var equalsTypeAttribute = context.Attributes[0].ConstructorArguments[0].Value;
        var equalsType = Enum.IsDefined(typeof(EqualsType), equalsTypeAttribute) ? (EqualsType)equalsTypeAttribute : GetDefaultEqualsType();
        var getHashCodeTypeAttribute = context.Attributes[0].ConstructorArguments[1].Value;
        var getHashCodeType = Enum.IsDefined(typeof(GetHashCodeType), getHashCodeTypeAttribute) ? (GetHashCodeType)getHashCodeTypeAttribute : GetDefaultGetHashCodeType();

        return new DiscriminatedUnionAttributeData(union, equalsType, getHashCodeType);
    }

    private static EqualsType GetDefaultEqualsType()
    {
        return EqualsType.Strict;
    }

    private static GetHashCodeType GetDefaultGetHashCodeType()
    {
        return GetHashCodeType.Strict;
    }

    private static DiscriminatedUnionTypesData TransformTypes(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var parsedAttributes = new List<ParsedType>();
        var attributes = context.Attributes;
        foreach (var attribute in attributes)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var arguments = attribute.ConstructorArguments;
            var typeArgument = (INamedTypeSymbol)arguments[0].Value;
            var fullTypeString = typeArgument.ToString();
            var dotIndex = fullTypeString.LastIndexOf('.');
            var typeName = dotIndex != -1 ? fullTypeString.Substring(dotIndex + 1) : fullTypeString;
            var isValueType = typeArgument.IsValueType;
            var customName = (string)arguments[1].Value;
            var priority = (int)arguments[2].Value;
            var shouldBox = (bool)arguments[3].Value;

            var parsed = new ParsedType(fullTypeString, typeName, isValueType, customName, priority, shouldBox);
            parsedAttributes.Add(parsed);
        }

        parsedAttributes.Sort((x, y) => y.Priority.CompareTo(x.Priority));
        var immutable = parsedAttributes.ToImmutableArray();
        var name = context.TargetSymbol.Name;
        var fullNamespace = GetFullNamespace(context.TargetSymbol);
        var union = new DiscriminatedUnionData(name, fullNamespace);

        var parsedUnion = new DiscriminatedUnionTypesData(union, immutable);
        return parsedUnion;
    }

    private static string GetFullNamespace(ISymbol symbol)
    {
        var namespaceBuilder = new StringBuilder();
        var currentNamespace = symbol.ContainingNamespace;
        while (currentNamespace is not null && !string.IsNullOrWhiteSpace(currentNamespace.Name))
        {
            if (namespaceBuilder.Length != 0)
            {
                namespaceBuilder.Insert(0, '.');
            }
            namespaceBuilder.Insert(0, currentNamespace.Name);
            currentNamespace = currentNamespace.ContainingNamespace;
        }

        return namespaceBuilder.ToString();
    }

    private static void AppendConstTags(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        builder.AppendLine($"{tab}{tab}private const byte TagNone = 0;");

        var tag = 1;
        foreach (var item in types)
        {
            builder.AppendLine($"{tab}{tab}private const byte {GenerateTagName(item)} = {tag}; // priority = {item.Priority}");
            tag++;
        }
    }

    private static string GenerateTagName(ParsedType type)
    {
        var str = NormalizeTypeName(type);

        return $"Tag{str}";
    }

    private static void AppendFields(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        if (types.Length == 0)
        {
            return;
        }

        var hasReferenceType = false;
        foreach (var type in types)
        {
            if (!type.IsValueType)
            {
                hasReferenceType = true;
                break;
            }
        }

        var offset = 0;
        if (hasReferenceType)
        {
            foreach (var type in types)
            {
                if (!type.IsValueType)
                {
                    var typeString = GetTypeString(type);
                    builder.AppendLine();
                    builder.AppendLine($"{tab}{tab}[FieldOffset({offset})]");
                    builder.AppendLine($"{tab}{tab}private readonly {typeString} {GenerateFieldName(type)};");
                }
            }

            offset += 8;
        }

        builder.AppendLine();
        builder.AppendLine($"{tab}{tab}[FieldOffset({offset})]");
        builder.AppendLine($"{tab}{tab}private readonly byte _tag;");
        offset++;

        foreach (var type in types)
        {
            if (type.IsValueType)
            {
                builder.AppendLine();
                builder.AppendLine($"{tab}{tab}[FieldOffset({offset})]");
                builder.AppendLine($"{tab}{tab}private readonly {type.FullTypeName} {GenerateFieldName(type)};");
            }
        }
    }

    private static string GenerateFieldName(ParsedType type)
    {
        return $"_{type.TypeName}";
    }

    private static void AppendConstructors(StringBuilder builder, MergedAttributesData data)
    {
        foreach (var type in data.Types)
        {
            var typeString = GetTypeString(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public {data.Union.Name}({typeString} value)");
            builder.AppendLine($"{tab}{tab}{{");

            // probably should use Unsafe.SkipInit(out);
            if (data.Types.Length > 1)
            {
                foreach (var otherType in data.Types)
                {
                    if (otherType == type)
                    {
                        continue;
                    }

                    builder.AppendLine($"{tab}{tab}{tab}{GenerateFieldName(otherType)} = default;");
                }

                builder.AppendLine();
            }

            builder.AppendLine($"{tab}{tab}{tab}{GenerateFieldName(type)} = value;");
            builder.AppendLine($"{tab}{tab}{tab}_tag = {GenerateTagName(type)};");
            builder.AppendLine($"{tab}{tab}}}");
        }
    }

    private static void AppendIsXyzMethods(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        foreach (var type in types)
        {
            var typeName = NormalizeTypeName(type);

            var tagName = GenerateTagName(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public readonly bool Is{typeName}()");
            builder.AppendLine($"{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}return _tag == {tagName};");
            builder.AppendLine($"{tab}{tab}}}");

            var typeString = GetTypeString(type);

            var fieldName = GenerateFieldName(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public readonly bool Is{typeName}(out {typeString} value)");
            builder.AppendLine($"{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}if (_tag == {tagName})");
            builder.AppendLine($"{tab}{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}{tab}value = {fieldName};");
            builder.AppendLine($"{tab}{tab}{tab}{tab}return true;");
            builder.AppendLine($"{tab}{tab}{tab}}}");
            builder.AppendLine($"{tab}{tab}{tab}value = default;");
            builder.AppendLine($"{tab}{tab}{tab}return false;");
            builder.AppendLine($"{tab}{tab}}}");
        }
    }

    private static string GetTypeString(ParsedType type)
    {
        return type.IsValueType ? type.FullTypeName : $"{type.FullTypeName}?"; // IF language version >=8.0
        // return type.FullTypeName; // otherwise
    }

    private static string NormalizeTypeName(ParsedType type)
    {
        var typeName = type.TypeName;
        if (!string.IsNullOrWhiteSpace(type.CustomName))
        {
            typeName = type.CustomName;
        }

        typeName = char.ToUpper(typeName[0]) + typeName.Substring(1);

        return typeName;
    }

    private static void AppendMatchMethod(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        builder.AppendLine();

        builder.Append($"{tab}{tab}public readonly TResult Match<TResult>(");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            builder.Append($"Func<{parameter}, TResult> process{typeName}");
            if (i < types.Length - 1)
            {
                builder.Append(", ");
            }
            else
            {
                builder.AppendLine(")");
            }
        }

        builder.AppendLine($"{tab}{tab}{{");
        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return process{typeName}({fieldName});");
        }

        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}throw new AwesomeDiscriminatedUnions.ExhaustedMatchCasesException($\"Unknown _tag = {{_tag}}\");");
        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }

    private static void AppendSwitchMethod(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        builder.AppendLine();

        builder.Append($"{tab}{tab}public readonly void Switch(");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            builder.Append($"Action<{parameter}> process{typeName}");
            if (i < types.Length - 1)
            {
                builder.Append(", ");
            }
            else
            {
                builder.AppendLine(")");
            }
        }

        builder.AppendLine($"{tab}{tab}{{");
        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}process{typeName}({fieldName});");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return;");
        }
        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}throw new AwesomeDiscriminatedUnions.ExhaustedSwitchCasesException($\"Unknown _tag = {{_tag}}\");");
        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }

    private static void AppendImplicitCastOperators(StringBuilder builder, MergedAttributesData data)
    {
        builder.AppendLine();

        foreach (var type in data.Types)
        {
            var typeString = GetTypeString(type);
            builder.AppendLine($"{tab}{tab}public static implicit operator {data.Union.Name}({typeString} value) => new {data.Union.Name}(value);");
        }
    }

    private static void AppendGetHashCodeMethod(StringBuilder builder, MergedAttributesData data)
    {
        if (data.GetHashCodeType == GetHashCodeType.None)
        {
            return;
        }

        builder.AppendLine();

        builder.AppendLine($"{tab}{tab}readonly public override int GetHashCode()");
        builder.AppendLine($"{tab}{tab}{{");

        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");

        foreach (var type in data.Types)
        {
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            if (data.GetHashCodeType == GetHashCodeType.Strict)
            {
                if (type.IsValueType)
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return HashCode.Combine(_tag, {fieldName});");
                }
                else
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return {fieldName} is not null ? HashCode.Combine(_tag, {fieldName}) : 0;");
                }
            }
            else if (data.GetHashCodeType == GetHashCodeType.Weak)
            {
                if (type.IsValueType)
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return {fieldName}.GetHashCode();");
                }
                else
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return {fieldName} is not null ? {fieldName}.GetHashCode() : 0;");
                }
            }
        }

        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return 0;");

        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }
}
