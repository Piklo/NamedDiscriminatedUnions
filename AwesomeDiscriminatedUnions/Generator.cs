using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Text;
using System.Threading;

namespace AwesomeDiscriminatedUnions;

internal readonly record struct DiscriminatedUnionAttributeParameters(EqualsType EqualsType, GetHashCodeType GetHashCodeType);

internal readonly record struct ParsedType(string FullTypeName, string TypeName, bool IsValueType, string CustomName, bool ShouldBox);

// remove the readonly if you ever add more attributes and just update the existing record with whatever changed in subsequent transforms
internal readonly record struct DiscriminatedUnionData(string Name, string FullNamespace, ImmutableArray<ParsedType> Types, DiscriminatedUnionAttributeParameters Parameters, bool IsRefStruct);

[Generator]
internal class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var discriminatedUnionData =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "AwesomeDiscriminatedUnions.DiscriminatedUnionAttribute",
                static (node, ct) => node is StructDeclarationSyntax,
                ParseDiscriminatedUnionData);

        context.RegisterSourceOutput(discriminatedUnionData, (productionContext, data) =>
        {
            var fileName = $"{data.Name}.g.cs";
            using var baseWriter = new StringWriter();
            using var writer = new IndentedTextWriter(baseWriter, new string(' ', 4));

            writer.WriteLine("// <auto-generated/>");
            writer.WriteLine($"// generated on {DateTimeOffset.Now}");
            writer.WriteLineNoTabs();
            writer.WriteLine("using System;");
            writer.WriteLine("using System.Runtime.InteropServices;");
            writer.WriteLineNoTabs();
            writer.WriteLine("#nullable enable");
            writer.WriteLineNoTabs();
            writer.WriteLine($"namespace {data.FullNamespace}");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("[StructLayout(LayoutKind.Explicit)]");

            var shouldAddIEquatable = !data.IsRefStruct && data.Parameters.EqualsType.HasFlag(EqualsType.IEquatable);
            writer.WriteLine($"partial struct {data.Name}{(shouldAddIEquatable ? $" : IEquatable<{data.Name}>" : "")}");

            writer.WriteLine("{");
            writer.Indent++;
            AppendConstTags(writer, data.Types);
            AppendFields(writer, data.Types);
            AppendConstructors(writer, data);
            AppendIsXyzMethods(writer, data.Types);
            AppendMatchMethod(writer, data.Types);
            AppendSwitchMethod(writer, data.Types);
            AppendImplicitCastOperators(writer, data);
            AppendGetHashCodeMethod(writer, data);
            AppendOverrideEqualsMethods(writer, data);
            AppendEqualsStrictMethod(writer, data);
            AppendEqualsOperator(writer, data);
            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");
            var code = baseWriter.ToString();
            productionContext.AddSource(fileName, code);
        });
    }

    private static DiscriminatedUnionData ParseDiscriminatedUnionData(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var parameters = GetDiscriminatedUnionAttributeParameters(context);

        var types = GetDiscriminatedUnionTypes(context, cancellationToken);

        var name = context.TargetSymbol.Name;
        var fullNamespace = GetFullNamespace(context.TargetSymbol);
        var isRefStruct = ((ITypeSymbol)context.TargetSymbol).IsRefLikeType;

        var data = new DiscriminatedUnionData(name, fullNamespace, types, parameters, isRefStruct);

        return data;
    }

    private static DiscriminatedUnionAttributeParameters GetDiscriminatedUnionAttributeParameters(GeneratorAttributeSyntaxContext context)
    {
        var duAttributeArguments = context.Attributes[0].ConstructorArguments;

        var equalsType = (EqualsType)duAttributeArguments[0].Value;
        var getHashCodeType = (GetHashCodeType)duAttributeArguments[1].Value;

        var parameters = new DiscriminatedUnionAttributeParameters(equalsType, getHashCodeType);

        return parameters;
    }

    private static ImmutableArray<ParsedType> GetDiscriminatedUnionTypes(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var parsedAttributes = new List<ParsedType>();
        var attributes = context.TargetSymbol.GetAttributes();
        foreach (var attribute in attributes)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (attribute.AttributeClass.Name != "DiscriminatedUnionTypeAttribute")
            {
                continue;
            }

            var arguments = attribute.ConstructorArguments;
            var typeArgument = (INamedTypeSymbol)arguments[0].Value;
            var fullTypeString = typeArgument.ToString();
            var dotIndex = fullTypeString.LastIndexOf('.');
            var typeName = dotIndex != -1 ? fullTypeString.Substring(dotIndex + 1) : fullTypeString;
            var isValueType = typeArgument.IsValueType;
            var customName = (string)arguments[1].Value;
            var shouldBox = (bool)arguments[2].Value;

            var parsed = new ParsedType(fullTypeString, typeName, isValueType, customName, shouldBox);
            parsedAttributes.Add(parsed);
        }

        var immutable = parsedAttributes.ToImmutableArray();

        return immutable;
    }

    private static string GetFullNamespace(ISymbol symbol)
    {
        var namespaceBuilder = new StringBuilder();
        var currentNamespace = symbol.ContainingNamespace;
        while (currentNamespace is not null && !string.IsNullOrWhiteSpace(currentNamespace.Name))
        {
            if (namespaceBuilder.Length != 0)
            {
                namespaceBuilder.Insert(0, '.');
            }
            namespaceBuilder.Insert(0, currentNamespace.Name);
            currentNamespace = currentNamespace.ContainingNamespace;
        }

        return namespaceBuilder.ToString();
    }

    private static void AppendConstTags(IndentedTextWriter writer, ImmutableArray<ParsedType> types)
    {
        writer.WriteLine("private const byte TagNone = 0;");

        var tag = 1;
        foreach (var item in types)
        {
            writer.WriteLine($"private const byte {GenerateTagName(item)} = {tag};");
            tag++;
        }
    }

    private static string GenerateTagName(ParsedType type)
    {
        var str = NormalizeTypeName(type);

        return $"Tag{str}";
    }

    private static void AppendFields(IndentedTextWriter writer, ImmutableArray<ParsedType> types)
    {
        if (types.Length == 0)
        {
            return;
        }

        var hasReferenceType = false;
        foreach (var type in types)
        {
            if (!type.IsValueType)
            {
                hasReferenceType = true;
                break;
            }
        }

        var offset = 0;
        if (hasReferenceType)
        {
            foreach (var type in types)
            {
                if (!type.IsValueType)
                {
                    var typeString = GetTypeString(type);
                    writer.WriteLineNoTabs();
                    writer.WriteLine($"[FieldOffset({offset})]");
                    writer.WriteLine($"private readonly {typeString} {GenerateFieldName(type)};");
                }
            }

            offset += 8;
        }

        writer.WriteLineNoTabs();
        writer.WriteLine($"[FieldOffset({offset})]");
        writer.WriteLine("private readonly byte _tag;");
        offset++;

        foreach (var type in types)
        {
            if (type.IsValueType)
            {
                writer.WriteLineNoTabs();
                writer.WriteLine($"[FieldOffset({offset})]");
                writer.WriteLine($"private readonly {type.FullTypeName} {GenerateFieldName(type)};");
            }
        }
    }

    private static string GenerateFieldName(ParsedType type)
    {
        return $"_{type.TypeName}";
    }

    private static void AppendConstructors(IndentedTextWriter writer, DiscriminatedUnionData data)
    {
        foreach (var type in data.Types)
        {
            var typeString = GetTypeString(type);

            writer.WriteLineNoTabs();
            writer.WriteLine($"public {data.Name}({typeString} value)");
            writer.WriteLine("{");
            writer.Indent++;

            if (data.Types.Length > 1)
            {
                foreach (var otherType in data.Types)
                {
                    if (otherType == type)
                    {
                        continue;
                    }

                    writer.WriteLine($"System.Runtime.CompilerServices.Unsafe.SkipInit(out {GenerateFieldName(otherType)});");
                }

                writer.WriteLineNoTabs();
            }

            writer.WriteLine($"{GenerateFieldName(type)} = value;");
            writer.WriteLine($"_tag = {GenerateTagName(type)};");
            writer.Indent--;
            writer.WriteLine("}");
        }
    }

    private static void AppendIsXyzMethods(IndentedTextWriter writer, ImmutableArray<ParsedType> types)
    {
        foreach (var type in types)
        {
            var typeName = NormalizeTypeName(type);

            var tagName = GenerateTagName(type);

            writer.WriteLineNoTabs();
            writer.WriteLine($"public readonly bool Is{typeName}()");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"return _tag == {tagName};");
            writer.Indent--;
            writer.WriteLine("}");

            var typeString = GetTypeString(type);

            var fieldName = GenerateFieldName(type);

            writer.WriteLineNoTabs();
            writer.WriteLine($"public readonly bool Is{typeName}(out {typeString} value)");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"if (_tag == {tagName})");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"value = {fieldName};");
            writer.WriteLine("return true;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine("value = default;");
            writer.WriteLine("return false;");
            writer.Indent--;
            writer.WriteLine("}");
        }
    }

    private static string GetTypeString(ParsedType type)
    {
        return type.IsValueType ? type.FullTypeName : $"{type.FullTypeName}?"; // IF language version >=8.0
        // return type.FullTypeName; // otherwise
    }

    private static string NormalizeTypeName(ParsedType type)
    {
        var typeName = type.TypeName;
        if (!string.IsNullOrWhiteSpace(type.CustomName))
        {
            typeName = type.CustomName;
        }

        typeName = char.ToUpper(typeName[0]) + typeName.Substring(1);

        return typeName;
    }

    private static void AppendMatchMethod(IndentedTextWriter writer, ImmutableArray<ParsedType> types)
    {
        writer.WriteLineNoTabs();

        writer.Write("public readonly TResult Match<TResult>(");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            writer.Write($"Func<{parameter}, TResult> process{typeName}");
            if (i < types.Length - 1)
            {
                writer.Write(", ");
            }
            else
            {
                writer.WriteLine(")");
            }
        }

        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("switch (_tag)");
        writer.WriteLine("{");
        writer.Indent++;
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            writer.WriteLine($"case {tag}:");
            writer.Indent++;
            writer.WriteLine($"return process{typeName}({fieldName});");
            writer.Indent--;
        }

        writer.WriteLine("default:");
        writer.Indent++;
        writer.WriteLine("throw new AwesomeDiscriminatedUnions.ExhaustedMatchCasesException($\"Unknown _tag = {_tag}\");");
        writer.Indent--;
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
    }

    // merge me with AppendMatchMethod?
    private static void AppendSwitchMethod(IndentedTextWriter writer, ImmutableArray<ParsedType> types)
    {
        writer.WriteLineNoTabs();

        writer.Write("public readonly void Switch(");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            writer.Write($"Action<{parameter}> process{typeName}");
            if (i < types.Length - 1)
            {
                writer.Write(", ");
            }
            else
            {
                writer.WriteLine(")");
            }
        }

        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("switch (_tag)");
        writer.WriteLine("{");
        writer.Indent++;
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            writer.WriteLine($"case {tag}:");
            writer.Indent++;
            writer.WriteLine($"process{typeName}({fieldName});");
            writer.WriteLine("return;");
            writer.Indent--;
        }

        writer.WriteLine("default:");
        writer.Indent++;
        writer.WriteLine("throw new AwesomeDiscriminatedUnions.ExhaustedSwitchCasesException($\"Unknown _tag = {_tag}\");");
        writer.Indent--;
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static void AppendImplicitCastOperators(IndentedTextWriter writer, DiscriminatedUnionData data)
    {
        writer.WriteLineNoTabs();

        foreach (var type in data.Types)
        {
            var typeString = GetTypeString(type);
            writer.WriteLine($"public static implicit operator {data.Name}({typeString} value) => new {data.Name}(value);");
        }
    }

    private static void AppendGetHashCodeMethod(IndentedTextWriter writer, DiscriminatedUnionData data)
    {
        if (data.Parameters.GetHashCodeType == GetHashCodeType.None)
        {
            return;
        }

        writer.WriteLineNoTabs();

        writer.WriteLine("readonly public override int GetHashCode()");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("switch (_tag)");
        writer.WriteLine("{");
        writer.Indent++;

        foreach (var type in data.Types)
        {
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            writer.WriteLine($"case {tag}:");
            writer.Indent++;
            if (data.Parameters.GetHashCodeType == GetHashCodeType.Strict)
            {
                if (type.IsValueType)
                {
                    writer.WriteLine($"return HashCode.Combine(_tag, {fieldName});");
                }
                else
                {
                    writer.WriteLine($"return {fieldName} is not null ? HashCode.Combine(_tag, {fieldName}) : 0;");
                }
            }
            else if (data.Parameters.GetHashCodeType == GetHashCodeType.Weak)
            {
                if (type.IsValueType)
                {
                    writer.WriteLine($"return {fieldName}.GetHashCode();");
                }
                else
                {
                    writer.WriteLine($"return {fieldName} is not null ? {fieldName}.GetHashCode() : 0;");
                }
            }
            writer.Indent--;
        }

        writer.WriteLine("default:");
        writer.Indent++;
        writer.WriteLine("return 0;");
        writer.Indent--;
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static void AppendOverrideEqualsMethods(IndentedTextWriter writer, DiscriminatedUnionData data)
    {
        if (!data.Parameters.EqualsType.HasFlag(EqualsType.OverrideEquals))
        {
            return;
        }

        writer.WriteLineNoTabs();
        writer.WriteLine("public override readonly bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"if (obj is not {data.Name} temp)");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("return false;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLineNoTabs();
        writer.WriteLine("return Equals(temp);");
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static void AppendEqualsStrictMethod(IndentedTextWriter writer, DiscriminatedUnionData data)
    {
        if (!data.Parameters.EqualsType.HasFlag(EqualsType.EqualsStrict))
        {
            return;
        }

        writer.WriteLineNoTabs();
        writer.WriteLine($"public readonly bool Equals({data.Name} other)");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("if (_tag != other._tag)");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"return false;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLineNoTabs();
        writer.WriteLine("switch (_tag)");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("case TagNone:");
        writer.Indent++;
        writer.WriteLine($"return true;");
        writer.Indent--;

        foreach (var type in data.Types)
        {
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            if (type.IsValueType)
            {
                writer.WriteLine($"case {tag}:");
                writer.Indent++;
                writer.WriteLine($"return {fieldName}.Equals(other.{fieldName});");
                writer.Indent--;
            }
            else
            {
                writer.WriteLine($"case {tag}:");
                writer.Indent++;
                writer.WriteLine($"if ({fieldName} == other.{fieldName})");
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("return true;");
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine($"if ({fieldName} is null || other.{fieldName} is null)");
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("return false;");
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLineNoTabs();
                writer.WriteLine($"return {fieldName}.Equals(other.{fieldName});");
                writer.Indent--;
            }
        }

        writer.WriteLine("default:");
        writer.Indent++;
        writer.WriteLine("return false;");
        writer.Indent--;
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static void AppendEqualsOperator(IndentedTextWriter writer, DiscriminatedUnionData data)
    {
        if (!data.Parameters.EqualsType.HasFlag(EqualsType.EqualsOperator))
        {
            return;
        }

        writer.WriteLineNoTabs();
        writer.WriteLine($"public static bool operator ==({data.Name} left, {data.Name} right) => left.Equals(right);");
        writer.WriteLineNoTabs();
        writer.WriteLine($"public static bool operator !=({data.Name} left, {data.Name} right) => !(left == right);");
    }
}
