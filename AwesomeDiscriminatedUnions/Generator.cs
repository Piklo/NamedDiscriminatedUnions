using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Threading;

namespace AwesomeDiscriminatedUnions;

internal readonly record struct GetHashCodeData(string UnionName, string FullNamespace, DiscriminatedUnionGetHashCodeType Type);

internal readonly record struct ParsedUnion(string Name, string FullNamespace, ImmutableArray<ParsedType> Types);

internal readonly record struct ParsedType(string FullTypeName, string TypeName, bool IsValueType, string CustomName, int Priority, bool ShouldBox);

// remove the readonly if you ever add more attributes and just update the existing record with whatever changed in subsequent transforms
internal readonly record struct MergedAttributesData(ParsedUnion ParsedUnion, DiscriminatedUnionGetHashCodeType GetHashCodeType);

[Generator]
internal class Generator : IIncrementalGenerator
{
    private readonly static string tab = new(' ', 4);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var duGetHashCode =
            context.SyntaxProvider.ForAttributeWithMetadataName("AwesomeDiscriminatedUnions.DiscriminatedUnionGetHashCodeAttribute", Predicate, TransformGetHashCodes)
            .Collect()
            .Select(static (codes, ct) =>
            {
                var dict = new Dictionary<(string unionName, string fullNamespace), DiscriminatedUnionGetHashCodeType>(codes.Length);
                foreach (var item in codes)
                {
                    dict.Add((item.UnionName, item.FullNamespace), item.Type);
                }
                return dict;
            });

        var duTypes =
            context.SyntaxProvider.ForAttributeWithMetadataName("AwesomeDiscriminatedUnions.DiscriminatedUnionTypeAttribute", Predicate, TransformTypes)
            .Collect();

        var mergedAttributes = duTypes.Combine(duGetHashCode).SelectMany(static (item, ct) =>
        {
            var unions = item.Left;
            var dict = item.Right;
            var list = new List<MergedAttributesData>(unions.Length);

            foreach (var union in unions)
            {
                ct.ThrowIfCancellationRequested();

                if (!dict.TryGetValue((union.Name, union.FullNamespace), out var type))
                {
                    type = DiscriminatedUnionGetHashCodeType.None;
                }

                list.Add(new MergedAttributesData(union, type));
            }

            return list;
        });

        context.RegisterSourceOutput(mergedAttributes, (productionContext, mergedAttributes) =>
        {
            var parsedUnion = mergedAttributes.ParsedUnion;
            var fileName = $"{parsedUnion.Name}.g.cs";
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine($"// generated on {DateTimeOffset.Now}");
            builder.AppendLine();
            builder.AppendLine("using System;");
            builder.AppendLine();
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {parsedUnion.FullNamespace}");
            builder.AppendLine("{");
            builder.AppendLine($"{tab}[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]");
            builder.AppendLine($"{tab}partial struct {parsedUnion.Name}");
            builder.AppendLine($"{tab}{{");
            AppendConstTags(builder, parsedUnion);
            AppendFields(builder, parsedUnion);
            AppendConstructors(builder, parsedUnion);
            AppendIsXyzMethods(builder, parsedUnion);
            AppendMatchMethod(builder, parsedUnion);
            AppendSwitchMethod(builder, parsedUnion);
            AppendImplicitCastOperators(builder, parsedUnion);
            builder.AppendLine($"{tab}}}");
            builder.AppendLine("}");
            var code = builder.ToString();
            Console.WriteLine();
            productionContext.AddSource(fileName, code);
        });
    }

    private static bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is StructDeclarationSyntax;
    }

    private static GetHashCodeData TransformGetHashCodes(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var name = context.TargetSymbol.Name;
        var fullNamespace = GetFullNamespace(context.TargetSymbol);

        if (context.Attributes.Length != 1)
        {
            return new GetHashCodeData(name, fullNamespace, DiscriminatedUnionGetHashCodeType.None);
        }

        var type = context.Attributes[0].ConstructorArguments[0];
        if (!Enum.IsDefined(typeof(DiscriminatedUnionGetHashCodeType), type.Value))
        {
            return new GetHashCodeData(name, fullNamespace, DiscriminatedUnionGetHashCodeType.None);
        }

        var value = (DiscriminatedUnionGetHashCodeType)type.Value;

        return new GetHashCodeData(name, fullNamespace, value);
    }

    private static ParsedUnion TransformTypes(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var parsedAttributes = new List<ParsedType>();
        var attributes = context.Attributes;
        foreach (var attribute in attributes)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var arguments = attribute.ConstructorArguments;
            var typeArgument = (INamedTypeSymbol)arguments[0].Value;
            var fullTypeString = typeArgument.ToString();
            var dotIndex = fullTypeString.LastIndexOf('.');
            var typeName = dotIndex != -1 ? fullTypeString.Substring(dotIndex + 1) : fullTypeString;
            var isValueType = typeArgument.IsValueType;
            var customName = (string)arguments[1].Value;
            var priority = (int)arguments[2].Value;
            var shouldBox = (bool)arguments[3].Value;

            var parsed = new ParsedType(fullTypeString, typeName, isValueType, customName, priority, shouldBox);
            parsedAttributes.Add(parsed);
        }

        parsedAttributes.Sort((x, y) => y.Priority.CompareTo(x.Priority));
        var immutable = parsedAttributes.ToImmutableArray();
        var name = context.TargetSymbol.Name;
        var fullNamespace = GetFullNamespace(context.TargetSymbol);

        var parsedUnion = new ParsedUnion(name, fullNamespace, immutable);
        return parsedUnion;
    }

    private static string GetFullNamespace(ISymbol symbol)
    {
        var namespaceBuilder = new StringBuilder();
        var currentNamespace = symbol.ContainingNamespace;
        while (currentNamespace is not null && !string.IsNullOrWhiteSpace(currentNamespace.Name))
        {
            if (namespaceBuilder.Length != 0)
            {
                namespaceBuilder.Insert(0, '.');
            }
            namespaceBuilder.Insert(0, currentNamespace.Name);
            currentNamespace = currentNamespace.ContainingNamespace;
        }

        return namespaceBuilder.ToString();
    }

    private static void AppendConstTags(StringBuilder builder, ParsedUnion union)
    {
        builder.AppendLine($"{tab}{tab}private const byte TagNone = 0;");

        var tag = 1;
        foreach (var item in union.Types)
        {
            builder.AppendLine($"{tab}{tab}private const byte {GenerateTagName(item)} = {tag}; // priority = {item.Priority}");
            tag++;
        }
    }

    private static string GenerateTagName(ParsedType type)
    {
        var str = NormalizeTypeName(type);

        return $"Tag{str}";
    }

    private static void AppendFields(StringBuilder builder, ParsedUnion union)
    {
        if (union.Types.Length == 0)
        {
            return;
        }

        var hasReferenceType = false;
        foreach (var type in union.Types)
        {
            if (!type.IsValueType)
            {
                hasReferenceType = true;
                break;
            }
        }

        var offset = 0;
        if (hasReferenceType)
        {
            foreach (var type in union.Types)
            {
                if (!type.IsValueType)
                {
                    var typeString = GetTypeString(type);
                    builder.AppendLine();
                    builder.AppendLine($"{tab}{tab}[System.Runtime.InteropServices.FieldOffset({offset})]");
                    builder.AppendLine($"{tab}{tab}private readonly {typeString} {GenerateFieldName(type)};");
                }
            }

            offset += 8;
        }

        builder.AppendLine();
        builder.AppendLine($"{tab}{tab}[System.Runtime.InteropServices.FieldOffset({offset})]");
        builder.AppendLine($"{tab}{tab}private readonly byte _tag;");
        offset++;

        foreach (var type in union.Types)
        {
            if (type.IsValueType)
            {
                builder.AppendLine();
                builder.AppendLine($"{tab}{tab}[System.Runtime.InteropServices.FieldOffset({offset})]");
                builder.AppendLine($"{tab}{tab}private readonly {type.FullTypeName} {GenerateFieldName(type)};");
            }
        }
    }

    private static string GenerateFieldName(ParsedType type)
    {
        return $"_{type.TypeName}";
    }

    private static void AppendConstructors(StringBuilder builder, ParsedUnion union)
    {
        foreach (var type in union.Types)
        {
            var typeString = GetTypeString(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public {union.Name}({typeString} value)");
            builder.AppendLine($"{tab}{tab}{{");

            // probably should use Unsafe.SkipInit(out);
            if (union.Types.Length > 1)
            {
                foreach (var otherType in union.Types)
                {
                    if (otherType == type)
                    {
                        continue;
                    }

                    builder.AppendLine($"{tab}{tab}{tab}{GenerateFieldName(otherType)} = default;");
                }

                builder.AppendLine();
            }

            builder.AppendLine($"{tab}{tab}{tab}{GenerateFieldName(type)} = value;");
            builder.AppendLine($"{tab}{tab}{tab}_tag = {GenerateTagName(type)};");
            builder.AppendLine($"{tab}{tab}}}");
        }
    }

    private static void AppendIsXyzMethods(StringBuilder builder, ParsedUnion union)
    {
        foreach (var type in union.Types)
        {
            var typeName = NormalizeTypeName(type);

            var tagName = GenerateTagName(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public readonly bool Is{typeName}()");
            builder.AppendLine($"{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}return _tag == {tagName};");
            builder.AppendLine($"{tab}{tab}}}");

            var typeString = GetTypeString(type);

            var fieldName = GenerateFieldName(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public readonly bool Is{typeName}(out {typeString} value)");
            builder.AppendLine($"{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}if (_tag == {tagName})");
            builder.AppendLine($"{tab}{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}{tab}value = {fieldName};");
            builder.AppendLine($"{tab}{tab}{tab}{tab}return true;");
            builder.AppendLine($"{tab}{tab}{tab}}}");
            builder.AppendLine($"{tab}{tab}{tab}value = default;");
            builder.AppendLine($"{tab}{tab}{tab}return false;");
            builder.AppendLine($"{tab}{tab}}}");
        }
    }

    private static string GetTypeString(ParsedType type)
    {
        return type.IsValueType ? type.FullTypeName : $"{type.FullTypeName}?"; // IF language version >=8.0
        // return type.FullTypeName; // otherwise
    }

    private static string NormalizeTypeName(ParsedType type)
    {
        var typeName = type.TypeName;
        if (!string.IsNullOrWhiteSpace(type.CustomName))
        {
            typeName = type.CustomName;
        }

        typeName = char.ToUpper(typeName[0]) + typeName.Substring(1);

        return typeName;
    }

    private static void AppendMatchMethod(StringBuilder builder, ParsedUnion union)
    {
        builder.AppendLine();

        builder.Append($"{tab}{tab}public readonly TResult Match<TResult>(");
        for (var i = 0; i < union.Types.Length; i++)
        {
            var type = union.Types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            builder.Append($"Func<{parameter}, TResult> process{typeName}");
            if (i < union.Types.Length - 1)
            {
                builder.Append(", ");
            }
            else
            {
                builder.AppendLine(")");
            }
        }

        builder.AppendLine($"{tab}{tab}{{");
        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");
        for (var i = 0; i < union.Types.Length; i++)
        {
            var type = union.Types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return process{typeName}({fieldName});");
        }

        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}throw new AwesomeDiscriminatedUnions.ExhaustedMatchCasesException($\"Unknown _tag = {{_tag}}\");");
        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }

    private static void AppendSwitchMethod(StringBuilder builder, ParsedUnion union)
    {
        builder.AppendLine();

        builder.Append($"{tab}{tab}public readonly void Switch(");
        for (var i = 0; i < union.Types.Length; i++)
        {
            var type = union.Types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            builder.Append($"Action<{parameter}> process{typeName}");
            if (i < union.Types.Length - 1)
            {
                builder.Append(", ");
            }
            else
            {
                builder.AppendLine(")");
            }
        }

        builder.AppendLine($"{tab}{tab}{{");
        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");
        for (var i = 0; i < union.Types.Length; i++)
        {
            var type = union.Types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}process{typeName}({fieldName});");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return;");
        }
        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}throw new AwesomeDiscriminatedUnions.ExhaustedSwitchCasesException($\"Unknown _tag = {{_tag}}\");");
        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }

    private static void AppendImplicitCastOperators(StringBuilder builder, ParsedUnion union)
    {
        builder.AppendLine();

        foreach (var type in union.Types)
        {
            var typeString = GetTypeString(type);
            builder.AppendLine($"{tab}{tab}public static implicit operator {union.Name}({typeString} value) => new {union.Name}(value);");
        }
    }
}
