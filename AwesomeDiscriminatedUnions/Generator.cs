using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Threading;

namespace AwesomeDiscriminatedUnions;

internal readonly record struct DiscriminatedUnionAttributeParameters(EqualsType EqualsType, GetHashCodeType GetHashCodeType);

internal readonly record struct ParsedType(string FullTypeName, string TypeName, bool IsValueType, string CustomName, int Priority, bool ShouldBox);

// remove the readonly if you ever add more attributes and just update the existing record with whatever changed in subsequent transforms
internal readonly record struct DiscriminatedUnionData(string Name, string FullNamespace, ImmutableArray<ParsedType> Types, DiscriminatedUnionAttributeParameters Parameters);

[Generator]
internal class Generator : IIncrementalGenerator
{
    private readonly static string tab = new(' ', 4);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var discriminatedUnionData =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "AwesomeDiscriminatedUnions.DiscriminatedUnionAttribute",
                static (node, ct) => node is StructDeclarationSyntax,
                ParseDiscriminatedUnionData);

        context.RegisterSourceOutput(discriminatedUnionData, (productionContext, data) =>
        {
            var fileName = $"{data.Name}.g.cs";
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine($"// generated on {DateTimeOffset.Now}");
            builder.AppendLine();
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Runtime.InteropServices;");
            builder.AppendLine();
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {data.FullNamespace}");
            builder.AppendLine("{");
            builder.AppendLine($"{tab}[StructLayout(LayoutKind.Explicit)]");
            builder.AppendLine($"{tab}partial struct {data.Name}");
            builder.AppendLine($"{tab}{{");
            AppendConstTags(builder, data.Types);
            AppendFields(builder, data.Types);
            AppendConstructors(builder, data);
            AppendIsXyzMethods(builder, data.Types);
            AppendMatchMethod(builder, data.Types);
            AppendSwitchMethod(builder, data.Types);
            AppendImplicitCastOperators(builder, data);
            AppendGetHashCodeMethod(builder, data);
            builder.AppendLine($"{tab}}}");
            builder.AppendLine("}");
            var code = builder.ToString();
            Console.WriteLine();
            productionContext.AddSource(fileName, code);
        });
    }

    private static DiscriminatedUnionData ParseDiscriminatedUnionData(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var parameters = GetDiscriminatedUnionAttributeParameters(context);

        var types = GetDiscriminatedUnionTypes(context, cancellationToken);

        var name = context.TargetSymbol.Name;
        var fullNamespace = GetFullNamespace(context.TargetSymbol);

        var data = new DiscriminatedUnionData(name, fullNamespace, types, parameters);

        return data;
    }

    private static DiscriminatedUnionAttributeParameters GetDiscriminatedUnionAttributeParameters(GeneratorAttributeSyntaxContext context)
    {
        var duAttributeArguments = context.Attributes[0].ConstructorArguments;

        var equalsTypeAttribute = duAttributeArguments[0].Value;
        var equalsType = Enum.IsDefined(typeof(EqualsType), equalsTypeAttribute) ? (EqualsType)equalsTypeAttribute : throw new InvalidCastException($"invalid enum value of {equalsTypeAttribute} of type {nameof(EqualsType)}");

        var getHashCodeTypeAttribute = duAttributeArguments[1].Value;
        var getHashCodeType = Enum.IsDefined(typeof(GetHashCodeType), getHashCodeTypeAttribute) ? (GetHashCodeType)getHashCodeTypeAttribute : throw new InvalidCastException($"invalid enum value of {equalsTypeAttribute} of type {nameof(EqualsType)}");

        var parameters = new DiscriminatedUnionAttributeParameters(equalsType, getHashCodeType);

        return parameters;
    }

    private static ImmutableArray<ParsedType> GetDiscriminatedUnionTypes(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var parsedAttributes = new List<ParsedType>();
        var attributes = context.TargetSymbol.GetAttributes();
        foreach (var attribute in attributes)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (attribute.AttributeClass.Name != "DiscriminatedUnionTypeAttribute")
            {
                continue;
            }

            var arguments = attribute.ConstructorArguments;
            var typeArgument = (INamedTypeSymbol)arguments[0].Value;
            var fullTypeString = typeArgument.ToString();
            var dotIndex = fullTypeString.LastIndexOf('.');
            var typeName = dotIndex != -1 ? fullTypeString.Substring(dotIndex + 1) : fullTypeString;
            var isValueType = typeArgument.IsValueType;
            var customName = (string)arguments[1].Value;
            var priority = (int)arguments[2].Value;
            var shouldBox = (bool)arguments[3].Value;

            var parsed = new ParsedType(fullTypeString, typeName, isValueType, customName, priority, shouldBox);
            parsedAttributes.Add(parsed);
        }

        parsedAttributes.Sort((x, y) => y.Priority.CompareTo(x.Priority));

        var immutable = parsedAttributes.ToImmutableArray();

        return immutable;
    }

    private static string GetFullNamespace(ISymbol symbol)
    {
        var namespaceBuilder = new StringBuilder();
        var currentNamespace = symbol.ContainingNamespace;
        while (currentNamespace is not null && !string.IsNullOrWhiteSpace(currentNamespace.Name))
        {
            if (namespaceBuilder.Length != 0)
            {
                namespaceBuilder.Insert(0, '.');
            }
            namespaceBuilder.Insert(0, currentNamespace.Name);
            currentNamespace = currentNamespace.ContainingNamespace;
        }

        return namespaceBuilder.ToString();
    }

    private static void AppendConstTags(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        builder.AppendLine($"{tab}{tab}private const byte TagNone = 0;");

        var tag = 1;
        foreach (var item in types)
        {
            builder.AppendLine($"{tab}{tab}private const byte {GenerateTagName(item)} = {tag}; // priority = {item.Priority}");
            tag++;
        }
    }

    private static string GenerateTagName(ParsedType type)
    {
        var str = NormalizeTypeName(type);

        return $"Tag{str}";
    }

    private static void AppendFields(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        if (types.Length == 0)
        {
            return;
        }

        var hasReferenceType = false;
        foreach (var type in types)
        {
            if (!type.IsValueType)
            {
                hasReferenceType = true;
                break;
            }
        }

        var offset = 0;
        if (hasReferenceType)
        {
            foreach (var type in types)
            {
                if (!type.IsValueType)
                {
                    var typeString = GetTypeString(type);
                    builder.AppendLine();
                    builder.AppendLine($"{tab}{tab}[FieldOffset({offset})]");
                    builder.AppendLine($"{tab}{tab}private readonly {typeString} {GenerateFieldName(type)};");
                }
            }

            offset += 8;
        }

        builder.AppendLine();
        builder.AppendLine($"{tab}{tab}[FieldOffset({offset})]");
        builder.AppendLine($"{tab}{tab}private readonly byte _tag;");
        offset++;

        foreach (var type in types)
        {
            if (type.IsValueType)
            {
                builder.AppendLine();
                builder.AppendLine($"{tab}{tab}[FieldOffset({offset})]");
                builder.AppendLine($"{tab}{tab}private readonly {type.FullTypeName} {GenerateFieldName(type)};");
            }
        }
    }

    private static string GenerateFieldName(ParsedType type)
    {
        return $"_{type.TypeName}";
    }

    private static void AppendConstructors(StringBuilder builder, DiscriminatedUnionData data)
    {
        foreach (var type in data.Types)
        {
            var typeString = GetTypeString(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public {data.Name}({typeString} value)");
            builder.AppendLine($"{tab}{tab}{{");

            // probably should use Unsafe.SkipInit(out);
            if (data.Types.Length > 1)
            {
                foreach (var otherType in data.Types)
                {
                    if (otherType == type)
                    {
                        continue;
                    }

                    builder.AppendLine($"{tab}{tab}{tab}{GenerateFieldName(otherType)} = default;");
                }

                builder.AppendLine();
            }

            builder.AppendLine($"{tab}{tab}{tab}{GenerateFieldName(type)} = value;");
            builder.AppendLine($"{tab}{tab}{tab}_tag = {GenerateTagName(type)};");
            builder.AppendLine($"{tab}{tab}}}");
        }
    }

    private static void AppendIsXyzMethods(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        foreach (var type in types)
        {
            var typeName = NormalizeTypeName(type);

            var tagName = GenerateTagName(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public readonly bool Is{typeName}()");
            builder.AppendLine($"{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}return _tag == {tagName};");
            builder.AppendLine($"{tab}{tab}}}");

            var typeString = GetTypeString(type);

            var fieldName = GenerateFieldName(type);

            builder.AppendLine();
            builder.AppendLine($"{tab}{tab}public readonly bool Is{typeName}(out {typeString} value)");
            builder.AppendLine($"{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}if (_tag == {tagName})");
            builder.AppendLine($"{tab}{tab}{tab}{{");
            builder.AppendLine($"{tab}{tab}{tab}{tab}value = {fieldName};");
            builder.AppendLine($"{tab}{tab}{tab}{tab}return true;");
            builder.AppendLine($"{tab}{tab}{tab}}}");
            builder.AppendLine($"{tab}{tab}{tab}value = default;");
            builder.AppendLine($"{tab}{tab}{tab}return false;");
            builder.AppendLine($"{tab}{tab}}}");
        }
    }

    private static string GetTypeString(ParsedType type)
    {
        return type.IsValueType ? type.FullTypeName : $"{type.FullTypeName}?"; // IF language version >=8.0
        // return type.FullTypeName; // otherwise
    }

    private static string NormalizeTypeName(ParsedType type)
    {
        var typeName = type.TypeName;
        if (!string.IsNullOrWhiteSpace(type.CustomName))
        {
            typeName = type.CustomName;
        }

        typeName = char.ToUpper(typeName[0]) + typeName.Substring(1);

        return typeName;
    }

    private static void AppendMatchMethod(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        builder.AppendLine();

        builder.Append($"{tab}{tab}public readonly TResult Match<TResult>(");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            builder.Append($"Func<{parameter}, TResult> process{typeName}");
            if (i < types.Length - 1)
            {
                builder.Append(", ");
            }
            else
            {
                builder.AppendLine(")");
            }
        }

        builder.AppendLine($"{tab}{tab}{{");
        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return process{typeName}({fieldName});");
        }

        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}throw new AwesomeDiscriminatedUnions.ExhaustedMatchCasesException($\"Unknown _tag = {{_tag}}\");");
        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }

    private static void AppendSwitchMethod(StringBuilder builder, ImmutableArray<ParsedType> types)
    {
        builder.AppendLine();

        builder.Append($"{tab}{tab}public readonly void Switch(");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var parameter = GetTypeString(type);

            var typeName = NormalizeTypeName(type);

            builder.Append($"Action<{parameter}> process{typeName}");
            if (i < types.Length - 1)
            {
                builder.Append(", ");
            }
            else
            {
                builder.AppendLine(")");
            }
        }

        builder.AppendLine($"{tab}{tab}{{");
        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");
        for (var i = 0; i < types.Length; i++)
        {
            var type = types[i];
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            var typeName = NormalizeTypeName(type);

            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}process{typeName}({fieldName});");
            builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return;");
        }
        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}throw new AwesomeDiscriminatedUnions.ExhaustedSwitchCasesException($\"Unknown _tag = {{_tag}}\");");
        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }

    private static void AppendImplicitCastOperators(StringBuilder builder, DiscriminatedUnionData data)
    {
        builder.AppendLine();

        foreach (var type in data.Types)
        {
            var typeString = GetTypeString(type);
            builder.AppendLine($"{tab}{tab}public static implicit operator {data.Name}({typeString} value) => new {data.Name}(value);");
        }
    }

    private static void AppendGetHashCodeMethod(StringBuilder builder, DiscriminatedUnionData data)
    {
        if (data.Parameters.GetHashCodeType == GetHashCodeType.None)
        {
            return;
        }

        builder.AppendLine();

        builder.AppendLine($"{tab}{tab}readonly public override int GetHashCode()");
        builder.AppendLine($"{tab}{tab}{{");

        builder.AppendLine($"{tab}{tab}{tab}switch (_tag)");
        builder.AppendLine($"{tab}{tab}{tab}{{");

        foreach (var type in data.Types)
        {
            var tag = GenerateTagName(type);
            var fieldName = GenerateFieldName(type);
            builder.AppendLine($"{tab}{tab}{tab}{tab}case {tag}:");
            if (data.Parameters.GetHashCodeType == GetHashCodeType.Strict)
            {
                if (type.IsValueType)
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return HashCode.Combine(_tag, {fieldName});");
                }
                else
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return {fieldName} is not null ? HashCode.Combine(_tag, {fieldName}) : 0;");
                }
            }
            else if (data.Parameters.GetHashCodeType == GetHashCodeType.Weak)
            {
                if (type.IsValueType)
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return {fieldName}.GetHashCode();");
                }
                else
                {
                    builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return {fieldName} is not null ? {fieldName}.GetHashCode() : 0;");
                }
            }
        }

        builder.AppendLine($"{tab}{tab}{tab}{tab}default:");
        builder.AppendLine($"{tab}{tab}{tab}{tab}{tab}return 0;");

        builder.AppendLine($"{tab}{tab}{tab}}}");
        builder.AppendLine($"{tab}{tab}}}");
    }
}
